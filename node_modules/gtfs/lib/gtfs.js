//load config.js
try {
  var config = require('../config.js');
} catch (e) {
  console.log(e)
}

var async = require('async')
  , mongoose = require('mongoose')
  , _ = require('underscore')
  , utils = require('./utils')
  , dbName = process.env['MONGO_NODE_DATABASE'] || config.mongo_node_database
  , host = process.env['MONGO_NODE_HOST'] || config.mongo_node_host
  , port = process.env['MONGO_NODE_PORT'] || config.mongo_node_port
  , db = (port) ? mongoose.connect(host, dbName, port) : mongoose.connect(host, dbName);

require('../models/Agency');
require('../models/Calendar');
require('../models/CalendarDate');
require('../models/FareAttribute');
require('../models/FareRule');
require('../models/FeedInfo');
require('../models/Frequencies');
require('../models/Route');
require('../models/Stop');
require('../models/Shape');
require('../models/ShapeArr');
require('../models/StopTime');
require('../models/Transfer');
require('../models/Trip');

var Agency = db.model('Agency')
  , Calendar = db.model('Calendar')
  , Route = db.model('Route')
  , Shape = db.model('Shape')
  , ShapeArr = db.model('ShapeArr')
  , Stop = db.model('Stop')
  , StopTime = db.model('StopTime')
  , Trip = db.model('Trip');


module.exports = {    
  agencies: function(cb){
    //gets a list of all agencies

    Agency.find({}, cb);
  },

  processShapes: function(agency_key, cb){
    shape_pts = [];


    // Clear the ShapeArr database
    // ---------------------------
    ShapeArr.remove({ agency_key: agency_key }, {safe: true}, cb);

    // Find all unique shapes
    // ----------------------
    Shape.find().distinct('shape_id', function(error, shapes) {
    //Shape.findOne().exec( function(error, this_shape) {
      if (shapes.length ) {

        var currIndex = 0;
        processThisShape(shapes[currIndex]);

        function doNextShape() {
          if (currIndex < shapes.length) {
            currIndex++;
            processThisShape(shapes[currIndex]);
          }
          else {
            console.log("Processed all shapes");
          }
        }

        function processThisShape(this_shape){
          // Setup
          // -----
          var queryString = "this.shape_id == \'"+this_shape+"\' ";
          //var queryString = "this.shape_id == \'"+this_shape.shape_id+"\' ";

          // Find all the points in this shape
          // ---------------------------------
          Shape.find({ $where : queryString }).exec(function(e, points) {
              if ( points.length ) {
                shape_pts.length = 0; // clear array
                points.forEach(function(pt){
                  shape_pts.push({
                    lat: pt.shape_pt_lat,
                    lon: pt.shape_pt_lon,
                    seq: pt.shape_pt_sequence
                  });
                });
                shape_pts.sort(function(a,b) { return parseFloat(a.seq) - parseFloat(b.seq) } );
                //console.log("Shape array "+this_shape.shape_id+" is:");
                //console.log(shape_pts);

                // Create an object of shape data
                // ------------------------------
                processed_shape = {
                    agency_key: agency_key
                  , shape_id: this_shape
                  , shape_pt_arr: shape_pts
                }

                // Create a model instance from that data
                // --------------------------------------
                shapeArr = new ShapeArr(processed_shape);

                // Add the model instance to the database
                // --------------------------------------
                shapeArr.save( function(error, data){
                  if(error){
                    console.log("Shape processing error: "+error);
                    doNextShape();
                  }
                  else{
                    console.log(currIndex+" / "+shapes.length);
                    doNextShape();
                  }
                });

              }
          });
        } // end async.foreach
      } // end if shapes.length
    }); // end shape.distinct
  }, // end processshapes

  getRoutesByAgency: function(agency_key, cb){
    //gets routes for one agency

    Route.find({ agency_key: agency_key }, cb);
  },

  
  getAgenciesByDistance: function(lat, lon, radius, cb){
    //gets all agencies within a radius
    
    if (_.isFunction(radius)) {
      cb = radius;
      radius = 25; // default is 25 miles
    }

    lat = parseFloat(lat);
    lon = parseFloat(lon);

    var radiusInDegrees = Math.round(radius/69*100000)/100000;
    
    Agency
      .where('agency_center')
      .near(lon, lat).maxDistance(radiusInDegrees)
      .exec(cb);
  },

  getRoutesByDistance: function(lat, lon, radius, cb){
    //gets all routes within a radius

    if (_.isFunction(radius)) {
      cb = radius;
      radius = 1; //default is 1 mile
    }

    lat = parseFloat(lat);
    lon = parseFloat(lon);

    var radiusInDegrees = Math.round(radius/69*100000)/100000
      , stop_ids = []
      , trip_ids = []
      , route_ids = []
      , routes = [];
  
    async.series([
      getStopsNearby,
      getTrips,
      getRoutes,
      lookupRoutes
    ], function(e, results){
      cb(e, routes);
    });
  
    function getStopsNearby(cb){
      Stop
        .where('loc')
        .near(lon, lat).maxDistance(radiusInDegrees)
        .exec(function(e, stops){
          if(stops.length){
            stops.forEach(function(stop){
              if(stop.stop_id){
                stop_ids.push(stop.stop_id);
              }
            });
            cb(e, 'stops');
          } else {
            cb(new Error('No stops within ' + radius + ' miles'), 'stops');
          }
        });
    }
  
    function getTrips(cb){
      StopTime
        .distinct('trip_id')
        .where('stop_id').in(stop_ids)
        .exec(function(e, results){
          trip_ids = results;
          cb(e, 'trips');
        });
    }
  
    function getRoutes(cb){
      Trip
        .distinct('route_id')
        .where('trip_id').in(trip_ids)
        .exec(function(e, results){
          if(results.length){
            route_ids = results;
            cb(null, 'routes');
          } else {
            cb(new Error('No routes to any stops within ' + radius + ' miles'), 'routes');
          }
        });
    }
  
    function lookupRoutes(cb){
      Route
        .where('route_id').in(route_ids)
        .exec(function(e, results){
          if(results.length){
            routes = results;
            cb(null, 'lookup');
          } else {
            cb(new Error('No information for routes'), 'lookup');
          }
        });
    }
  },

  getStopsByRoute: function(agency_key, route_id, direction_id, cb){
    //gets stops for one route
    
    if (_.isFunction(direction_id)) {
      cb = direction_id;
      direction_id = null;
    }

    var stopTimes = []
      , longestTrip = []
      , stops = []
      , trip_ids = []
      , stop_ids = [];
  
    async.series([
      getTrips,
      getStopTimes,
      getStops
    ], function(e, results){
      cb(e, stops);
    });

    function getTrips(cb){
      Trip
        .count({
            agency_key: agency_key
          , route_id: route_id
        }, function(e, tripCount){
          if(tripCount){
            //grab up to 30 random samples from trips to find longest one
            var count = 0;
            async.whilst(
              function(){ return count < (( tripCount > 30 ) ? 30 : tripCount) },
              function (cb) {
                count++;
                Trip
                  .findOne({ 
                      agency_key: agency_key
                      , route_id: route_id
                      , direction_id: direction_id
                  })
                  .skip(Math.floor(Math.random()*tripCount))
                  .exec(function(e, trip){
                    try{
                      trip_ids.push(trip.trip_id);
                      cb();
                    } catch (e) {
                      cb();
                    }
                  });
            
              },
              function(e){
                cb(null, 'trips')
              });
          } else {
            cb(new Error('Invalid agency_key or route_id'), 'trips');
          }
        }); 
    }

    function getStopTimes(cb){
      async.forEach(
        trip_ids,
        function(trip_id, cb){
          StopTime.find(
              { agency_key: agency_key, trip_id: trip_id }
            , null
            , {sort: 'stop_sequence'}
            , function(e, stopTimes){
                //compare to longest trip to see if trip length is longest
                if(stopTimes.length && stopTimes.length > longestTrip.length){
                  longestTrip = stopTimes;
                }
                cb();
              }
          );
      
        }, function(e){
          cb(null, 'times');
        }
      );
    }

    function getStops(cb){
      async.forEachSeries(
        longestTrip, 
        function(stopTime, cb){
          Stop.findOne(
              { agency_key: agency_key, stop_id: stopTime.stop_id }
            , function(e, stop){
                stops.push(stop);
                cb();
              }
          );
        }, function(e){
          if(e){
            cb(new Error('No stops found'), 'stops');
          } else {
            cb(null, 'stops');
          }
        });
    }
  },

  // ==== EB Added ===

  getTripsByRoute: function(agency_key, route_id, cb){
    var query = { agency_key: agency_key, route_id: route_id}
    Trip.find(query).exec(
      function(e, trips){
        if (e) {
          console.log(e);
          cb(e, null);
        }
        else {
          // console.log(trips);
          cb(null, trips);
        }
      }
    );
  },

  getShapeIdsByRoute: function(agency_key, route_id, cb){
    //gets shapes for one route

    var query = { agency_key: agency_key, route_id: route_id}
      , shapeid = [];

    async.series([
      getShapeIds
    ], function(e, results){
      if(e){
        console.log(e);
        cb(e, null);
      } else {
        cb(e, shapeid);
      }
    });


    function getShapeIds(cb) {
      //Trip.find(query).sort("shape_id").exec(
      Trip.find(query).sort("shape_id").exec(
        function(e, trips){
          if ( trips.length ) {
            //console.log("Matches "+trips.length+" trips");
            trips.forEach(function(trip){
              if (shapeid.indexOf(trip.shape_id) == -1) {
                console.log("shape id is: "+trip.shape_id);
                shapeid.push(trip.shape_id);
              }
            });
            cb();
          }
        }
      );
    }
  },

  getShape: function(agency_key, shape_id, cb) {
    //gets one shape

    var query = { agency_key: agency_key, shape_id: shape_id}
      , shape = [];

    var queryString = "this.shape_id == \'"+shape_id+"\' ";
    // console.log(queryString); 
    Shape.find({ $where : queryString }).exec(function(e, points) {
        if ( points.length ) {
          points.forEach(function(pt){
            shape.push({
              lat: pt.shape_pt_lat,
              lon: pt.shape_pt_lon,
              seq: pt.shape_pt_sequence
            });
          });
          shape.sort(function(a,b) { return parseFloat(a.seq) - parseFloat(b.seq) } );
          cb(e, shape);
        }
    });
  },

  getShapesByRoute: function(agency_key, route_id, cb){
    //gets shapes for one route

    var query = { agency_key: agency_key, route_id: route_id}
      , shape = []
      , shapeid = [];

    console.log(query);

    async.series([
      getTrips
    ], function(e, results){
      if(e){
        console.log(e);
        cb(e, null);
      } else {
        console.log(results);
        // Put shape points in order
          shape.sort(function(a,b) { return parseFloat(a.seq) - parseFloat(b.seq) } );
        // Simplify point object - simply use position in array for sequence
          //shape.forEach(function(sh, i, e){
          //  shape[i] = [sh.lat, sh.lon];
          //});
        cb(e, shape);
      }
    });


    function getTrips(cb) {
      //Trip.find(query).sort("shape_id").exec(
      Trip.findOne(query).sort("shape_id").exec(
        function(e, trips){
          getPoints(trips.shape_id, cb);
          // if ( trips.length ) {
          //   console.log("Matches "+trips.length+" trips");
          //   trips.forEach(function(trip){
          //     if (shapeid.indexOf(trip.shape_id) == -1) {
          //       console.log("shape id is: "+trip.shape_id);
          //       shapeid.push(trip.shape_id);
          //       // getPoints(trip.shape_id, cb);
          //     }
          //   });
          // }
        }
      );
    }

    function getPoints(id, cb) {
      var queryString = "this.shape_id == \'"+id+"\' ";
      // console.log(queryString); 
      Shape.find({ $where : queryString }).exec(function(e, points) {
          console.log("Error: "+e);
          //console.log("points for id \'"+id+"\' are ("+points+")");
          if ( points.length ) {
            console.log("Shape has "+points.length+" points");
            points.forEach(function(pt){
              //console.log("pt: "+pt);
              // console.log("pt: "+pt.shape_pt_sequence);
              shape.push({
                lat: pt.shape_pt_lat,
                lon: pt.shape_pt_lon,
                seq: pt.shape_pt_sequence
              });
            });
            cb();
          }
      });
    }

  },

  // ================


  getStopsByDistance: function(lat, lon, radius, cb){
    //gets all stops within a radius

    if (_.isFunction(radius)) {
      cb = radius;
      radius = 1; //default is 1 mile
    }

    lat = parseFloat(lat);
    lon = parseFloat(lon);

    var radiusInDegrees = Math.round(radius/69*100000)/100000;

    Stop
      .where('loc')
      .near(lon, lat).maxDistance(radiusInDegrees)
      .exec(function(e, results){
        cb(e, results);
      });
  },


  getTimesByStop: function(agency_key, route_id, stop_id, direction_id, cb){
    //gets routes for one agency
    
    if (_.isFunction(direction_id)) {
      cb = direction_id;
      direction_id = null; //default is ~ 1/4 mile
    }

    var today = new Date(2013,00,23,9,1) // try the future - eb
      , service_ids = []
      , trip_ids = []
      , times = [];

      console.log("Today is: "+today); // - eb

    //Find service_id that matches todays date
    async.series([
      checkFields,
      findServices,
      findTrips,
      findTimes
    ], function(e, results){
      if(e){
        console.log(e);
        cb(e, null);
      } else {
        console.log(results);
        cb(e, times);
      }
    });

    function checkFields(cb){
      if(!agency_key){
        cb(new Error('No agency_key specified'), 'fields');
      } else if(!stop_id){
        cb(new Error('No stop_id specified'), 'fields');
      } else if(!route_id){
        cb(new Error('No route_id specified'), 'fields');
      } else {
        cb(null, 'fields');
      }
    }

    function findServices(cb){
      var query = { agency_key: agency_key }
        , todayFormatted = utils.formatDay(today);
   
        console.log(today);
        console.log(todayFormatted);

      //build query
      query[utils.getDayName(today).toLowerCase()] = 1;
  
      Calendar
        .find(query)
        .where('start_date').lte( todayFormatted )
        .where('end_date').gte( todayFormatted )
        .exec(function(e, services){
          if(services.length){
            services.forEach(function(service){
              service_ids.push(service.service_id);
              // console.log(service.service_id); // - eb --> these exist
            });
            cb(null, 'services');
          } else {
            cb(new Error('No Service for this date'), 'services');
          }
        });
    }

    function findTrips(cb){
      var query = {
        agency_key: agency_key,
        route_id: route_id,
        direction_id: direction_id
      }
      Trip
        .find(query)
        .where('service_id').in(service_ids)
        .exec(function(e, trips){
          if(trips.length){
            trips.forEach(function(trip){
              trip_ids.push(trip.trip_id);
              // console.log(trip.trip_id); // - eb --> these exist
            });
            cb(null, 'trips')
          } else {
            cb(new Error('No trips for this date'), 'trips');
          }
        });
    }

    function findTimes(cb){
      var query = {
          agency_key: agency_key,
          stop_id: stop_id
        }
        , timeFormatted = utils.timeToSeconds(today);
      StopTime
        .find(query)
        .where('trip_id').in(trip_ids)
        .where('departure_time')//.gte(timeFormatted) -
                                // ^ we can't use gte here because we're comparing the
                                // original ##:##:## string with a time in seconds
        .sort('departure_time') // switched from .asc() to sort, which defaults ascending - eb
        .exec(function(e, stopTimes){
          if(stopTimes.length){
            stopTimes.forEach(function(stopTime){
              if (stopTime.departure_time >= timeFormatted){ // moved the .gte() above to here, because it didn't work correctly above
                times.push({
                  time: utils.secondsToTime(stopTime.departure_time),
                  trip: stopTime.trip_id
                }); // return as ##:##:## instead of seconds - eb
              }
            });
            cb(null, 'times');
          } else {
            cb(new Error('No times available for this stop on this date'), 'times');
          }
        });
    }
  }
}


